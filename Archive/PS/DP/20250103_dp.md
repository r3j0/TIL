# 습격자 초라기 (Dynamic Programming)
Date : 2025. 01. 03

[백준 1006 : 습격자 초라기 (PLATINUM 3)](https://www.acmicpc.net/problem/1006) 문제를 풀이하였습니다.  

## 사고 과정
- 한 특수 소대는 특정 한 구역과 동시에 인접한 다른 한 구역을 커버할 수 있는 건, 2xn 구역을 1x1, 2x1, 1x2 로 타일링하는 것과 유사하다! 동시에 두 구역을 커버할 땐 적의 합이 w보다 작거나 같은지 확인한다.

### 점화식 정립 과정
- dp는 한 열을 기준으로 배열을 만들되, 5가지 형태를 구분한다.
![image](https://github.com/user-attachments/assets/aafd1653-c353-4f79-a801-637fb81da301)
> - [0] : 이전 열이 모두 커버되었다고 가정하고, **두 소대가 두 곳을 각각 커버하므로 특수 소대 수가 이전 열 전체 경우에서 2개 증가한다.**
> - [1] : 이전 열이 모두 커버되었다고 가정하고, 커버할 두 곳의 적의 합이 w보다 작거나 같다면, **한 소대가 두 곳을 동시에 커버하므로 특수 소대 수가 이전 열 전체 경우에서 1개 증가한다.**
> - [2] : 이전 열의 위쪽이 동시에 커버되어있지 않고, 한 소대가 그 구역만 커버하고 있을 때 **([0], [3] 경우)**, 이전 열 위쪽과 현재 열 위쪽의 적의 합이 w보다 작거나 같다면, **위쪽은 이전 열 소대가 동시에 커버하므로 특수 소대 수가 증가하지 않고, 아래쪽은 새 소대가 커버하므로 이전 열 경우 중 [0], [3] 경우에서 1개 증가한다.**
> - [3] : 이전 열의 아래쪽이 동시에 커버되어있지 않고, 한 소대가 그 구역만 커버하고 있을 때 **([0], [2] 경우)**, 이전 열 아래쪽과 현재 열 아래쪽의 적의 합이 w보다 작거나 같다면, **아래쪽은 이전 열 소대가 동시에 커버하므로 특수 소대 수가 증가하지 않고, 위쪽은 새 소대가 커버하므로 이전 열 경우 중 [0], [2] 경우에서 1개 증가한다.**
> - [4] : 이전 열의 위쪽과 아래쪽이 동시에 커버되어있지 않고, 두 소대가 각각 그 구역만 커버하고 있을 때 **([0] 경우)**, 이전 열 위쪽 + 현재 열 위쪽의 적의 합이 w보다 작거나 같고, 이전 열 아래쪽 + 현재 열 아래쪽의 적의 합이 w보다 작거나 같다면, **위쪽과 아래쪽 모두 이전 열 소대가 동시에 커버하므로 이전 열 경우 중 [0] 경우에서 소대 수가 증가하지 않는다.**

### 원형 가장자리 해결 과정
- 0부터 n-1까지는 선형으로 DP 배열 값을 전파시키되, **인덱스 0 에서 어떻게 소대를 배치했는지에 대한 경우를 전부 나누어, 인덱스 n-1과 올바르게 연결되는 경우만 찾을 수 있도록 구현한다.**
  
> - 인덱스 0에서 시작을 [0], [1] 경우로 했다면 -> 인덱스 n-1 모든 경우와 연결이 가능하다.
> - 인덱스 0에서 시작을 [2] 경우로 했다면 -> 인덱스 n-1의 [0], [3] 경우와 연결한다.
> - 인덱스 0에서 시작을 [3] 경우로 했다면 -> 인덱스 n-1의 [0], [2] 경우와 연결한다.
> - 인덱스 0에서 시작을 [4] 경우로 했다면 -> 인덱스 n-1의 [0] 경우와 연결한다.

## 풀이 코드
```py
# 1006 : 습격자 초라기
import sys
input = sys.stdin.readline

t = int(input().rstrip())
for _ in range(t):
    n, w = map(int, input().rstrip().split())
    arr = [list(map(int, input().rstrip().split())) for _ in range(2)]
    ans = float('inf')

    dp = [[float('inf') for _ in range(5)] for _ in range(n)]
    # dp[i][j] : i번째 열을 j번째 형태로 끝나도록 특수 소대를 배치했을 때 최소 소대 수

    def traversalDP(mode):
        # traversalDP(mode) : DP 배열 값 전파 함수
        #   모든 경우들을 i >= 2 일때 전파하도록 조건을 달아놓되, mode가 True로 들어오면 [0], [1] 경우만 전파 가능하도록 구현했습니다.
        #  
        #   -> 시작을 어떻게 할지 미리 정해놓기 때문에, 이전 열과 연결하는 [2], [3], [4] 경우는 
        #      불필요한 값이 쌓이지 않도록 인덱스 1을 스킵해야 합니다. (인덱스 0, 인덱스 1에 DP 초기값을 설정함)
        #   -> 다만 시작을 [0], [1] 경우로 시작했다면 인덱스 1 전파가 필요하기 때문에 (인덱스 0만 DP 초기값 설정), 
        #      [0], [1] 경우에선 mode 를 True로 설정합니다.

        global dp
        for i in range(1, n):

            if mode or i >= 2: # [0], [1] 경우로 시작했거나, 인덱스 i가 2 이상일 때
                # [0] : 이전 열 전체 경우에서 +2
                for j in range(5):
                    dp[i][0] = min(dp[i][0], dp[i-1][j] + 2)
                
                # [1] : 현재 열 두 곳이 연결 가능하다면 (<= w), 이전 열 전체 경우에서 +1
                if arr[0][i] + arr[1][i] <= w:
                    for j in range(5):
                        dp[i][1] = min(dp[i][1], dp[i-1][j] + 1)
            
            if i >= 2: # 인덱스 i가 2 이상일 때
                # [2] : 위쪽이 이전 열과 연결 가능하다면 (<= w), 이전 열 [0], [3] 경우 (이전 열 위쪽이 연결되지 않은 경우) 에서 +1
                if arr[0][i-1] + arr[0][i] <= w:
                    for j in [0, 3]:
                        dp[i][2] = min(dp[i][2], dp[i-1][j] + 1)

                # [3] : 아래쪽이 이전 열과 연결 가능하다면 (<= w), 이전 열 [0], [2] 경우 (이전 열 아래쪽이 연결되지 않은 경우) 에서 +1
                if arr[1][i-1] + arr[1][i] <= w:
                    for j in [0, 2]:
                        dp[i][3] = min(dp[i][3], dp[i-1][j] + 1)
            
                # [4] : 위쪽 아래쪽 둘 다 이전 열과 연결 가능하다면 (<= w), 
                #       이전 열 [0] 경우 (이전 열 둘 다 연결되지 않은 경우) 가져오기 (이전 열 소대가 동시에 커버)
                if arr[0][i-1] + arr[0][i] <= w and arr[1][i-1] + arr[1][i] <= w:
                    dp[i][4] = min(dp[i][4], dp[i-1][0])
    
    def findAnswer(mode):
        # findAnswer(mode) : 원형 지역 가장자리 해결 및 올바른 경우를 찾는 함수
        #   [0], [1], [2], [3], [4] 시작 경우 모두, 가장자리(0 <-> n-1)끼리 연결되지 않은 최소 경우는 min(dp[n-1]) 입니다.
        #   시작 경우를 어떻게 했는지에 따라, 각기 다르게 특정 경우만 처리하여 ans 값을 판정할 수 있도록 구현했습니다.
        global ans
        global dp

        ans = min(ans, min(dp[n-1]))

        if n >= 2:
            if mode[0] == 1:
                # [2] : 인덱스 n-1 위쪽과 인덱스 0 위쪽 연결이 가능하다면..
                if arr[0][n-1] + arr[0][0] <= w:
                    for j in [0, 3]:
                        ans = min(ans, dp[n-1][j] - 1)
            if mode[1] == 1:
                # [3] : 인덱스 n-1 아래쪽과 인덱스 0 아래쪽 연결이 가능하다면..
                if arr[1][n-1] + arr[1][0] <= w:
                    for j in [0, 2]:
                        ans = min(ans, dp[n-1][j] - 1)
            if mode[2] == 1:
                # [4] : 인덱스 n-1 위쪽과 인덱스 0 위쪽 연결, 인덱스 n-1 아래쪽과 인덱스 0 아래쪽 연결이 가능하다면..
                if arr[0][n-1] + arr[0][0] <= w and arr[1][n-1] + arr[1][0] <= w:
                    ans = min(ans, dp[n-1][0] - 2)

    # - 시작 경우 나누기

    # [0]
    dp = [[float('inf') for _ in range(5)] for _ in range(n)]
    dp[0][0] = 2

    traversalDP(True)
    findAnswer([1,1,1])
    
    # [1]
    dp = [[float('inf') for _ in range(5)] for _ in range(n)]
    if arr[0][0] + arr[1][0] <= w: # 인덱스 0 위쪽과 아래쪽 연결이 가능하다면
        dp[0][1] = 1
    
    traversalDP(True)
    findAnswer([0,0,0])

    if n >= 2:
        # [2]
        if arr[0][0] + arr[0][1] <= w: # 인덱스 0 위쪽과 인덱스 1 위쪽 연결이 가능하다면
            dp = [[float('inf') for _ in range(5)] for _ in range(n)]
            dp[1][2] = 3

            traversalDP(False)
            findAnswer([0,1,0])

        # [3]
        if arr[1][0] + arr[1][1] <= w: # 인덱스 0 아래쪽과 인덱스 1 아래쪽 연결이 가능하다면
            dp = [[float('inf') for _ in range(5)] for _ in range(n)]
            dp[1][3] = 3

            traversalDP(False)
            findAnswer([1,0,0])
        
        # [4]
        if arr[0][0] + arr[0][1] <= w and arr[1][0] + arr[1][1] <= w: 
            # 인덱스 0 위쪽과 인덱스 1 위쪽 연결, 인덱스 0 아래쪽과 인덱스 1 아래쪽 연결이 가능하다면
            dp = [[float('inf') for _ in range(5)] for _ in range(n)]
            dp[1][4] = 2

            traversalDP(False)
            findAnswer([0,0,0])
        
    print(ans)
```

## 평가
- 플래티넘 3 DP 를 자력으로 풀이해서 기분이 좋다. 평소에는 노트로 풀지 않다가 노트로 풀이해봤는데, 더 잘 풀리는 느낌이 들기도 한다. 
- 원형 DP를 처리하는 문제를 많이 풀어봐야 할 것 같다. 가장자리 처리 방법이랍시고 구현했는데 정해가 아닌 것 같다.
