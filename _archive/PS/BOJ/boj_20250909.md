## 백준 문제 풀이 (6문제)

### [2442번: 별 찍기 - 5 (BRONZE 3)](https://www.acmicpc.net/problem/2442)
```py
# 2442 : 별 찍기 - 5
import sys
input = sys.stdin.readline

n = int(input().rstrip())
for i in range(n):
    print(' '*(n-i-1) + '*' * (2*i+1))
```

### [1100번: 하얀 칸 (BRONZE 2)](https://www.acmicpc.net/problem/1100)
```py
# 1100 : 하얀 칸
import sys
input = sys.stdin.readline

maps = [input().rstrip() for _ in range(8)]
cnt = 0
for i in range(8):
    for j in range(8):
        if (i + j) % 2: continue
        if maps[i][j] == 'F': cnt += 1
print(cnt)
```

### [1145번: 적어도 대부분의 배수 (BRONZE 1)](https://www.acmicpc.net/problem/1145)
```py
# 1145 : 적어도 대부분의 배수
import sys
import math
input = sys.stdin.readline

arr = list(map(int, input().rstrip().split()))
res = 10000000
for i in range(3):
    for j in range(i+1, 4):
        for k in range(j+1, 5):
            res = min(res, math.lcm(math.lcm(arr[i], arr[j]), arr[k]))
print(res)
```

### [13909번: 창문 닫기 (SILVER 5)](https://www.acmicpc.net/problem/13909)
```py
# 13909 : 창문 닫기
import sys
input = sys.stdin.readline

n = int(input().rstrip())
cnt = 1
while cnt**2 <= n:
    cnt += 1
cnt -= 1
print(cnt)
```

예제를 몇 개 구해보면서 풀이할 수도 있지만, 해당 수의 약수만큼 열렸다 닫혔다를 반복하기에 마지막에 창문이 열리기 위해선 약수가 홀수개여야 한다. 즉 열린 창문의 번호는 제곱수이다.

### [3986번: 좋은 단어 (SILVER 4)](https://www.acmicpc.net/problem/3986)
```py
# 3986 : 좋은 단어
import sys
from collections import deque
input = sys.stdin.readline

n = int(input().rstrip())
arr = [input().rstrip() for _ in range(n)]
res = 0

for a in arr:
    q = deque()
    for c in a:
        if not q or q[-1] != c: q.append(c)
        else: q.pop()
    if not q: res += 1

print(res)
```

### [32930번: 슈팅 연습 (SILVER 5)](https://www.acmicpc.net/problem/32930)
```py
# 32930 : 슈팅 연습
import sys
input = sys.stdin.readline

n, m = map(int, input().rstrip().split())
arr = [list(map(int, input().rstrip().split())) for _ in range(n + m)] # 과녁 좌표
vis = [False for _ in range(n + m)] # 과녁 방문 여부

now_cursor = [0, 0] # 현재 커서
now_score = 0 # 현재 얻은 점수

def dist(c1, c2): # 거리 제곱값
    return ((c1[0] - c2[0])**2 + (c1[1] - c2[1])**2)

for i in range(m):
    max_index = -1
    max_dist = -1

    for j in range(n+i): # 현재까지 n+i개의 과녁이 화면에 나타남.
        if vis[j]: continue # 이미 사라진 과녁은 제외

        now_dist = dist(arr[j], now_cursor)
        if max_dist < now_dist:
            max_index = j
            max_dist = now_dist
    
    vis[max_index] = True # 과녁 사라짐
    now_score += max_dist
    now_cursor = list(arr[max_index])

print(now_score)
```

