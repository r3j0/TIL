# 문자열의 주기 예측 (KMP + DP)
Date : 2025. 01. 11

[백준 1787 : 문자열의 주기 예측 (PLATINUM 2)](https://www.acmicpc.net/problem/1787) 문제를 풀이하였습니다.  

## 사고 과정
- 추정 가능한 주기 중 가장 긴 주기를 구하기 위해서는, 뒤쪽 문자열이 반복되는 꼴이 되어 앞쪽 문자열이 된다는 사실이 성립되면서 (앞쪽 문자열이 뒤쪽 문자열로 시작하는 문자열이다.), 그 앞쪽 문자열이 가장 긴 경우를 찾아야 한다.
- 앞쪽 문자열이 뒤쪽 문자열로 시작하는 문자열이 되는 경우가 성립할 수도 있고, 성립하지 않을 수도 있는 상황을 고려해보기 위해 일단 예제 케이스를 가지고 하나씩 분해해보았다.
```
babababa
[2]
1_1 이 성립하려면 : [0] == [1]
[3]
2_1 이 성립하려면 : [0] == [2]
[4]
2_2 이 성립하려면 : 2_1이 성립하고, [1] == [3]
3_1 이 성립하려면 : [0] == [3]
[5] 
3_2 이 성립하려면 : 3_1이 성립하고, [1] == [4]
4_1 이 성립하려면 : [0] == [4]
[6]
3_3 이 성립하려면 : 3_2이 성립하고, [2] == [5]
4_2 이 성립하려면 : 4_1이 성립하고, [1] == [5]
5_1 이 성립하려면 : [0] == [5]
[7]
4_3 이 성립하려면 : 4_2이 성립하고, [2] == [6]
5_2 이 성립하려면 : 5_1이 성립하고, [1] == [6]
6_1 이 성립하려면 : [0] == [6]
[8]
4_4 이 성립하려면 : 4_3이 성립하고, [3] == [7]
5_3 이 성립하려면 : 5_2이 성립하고, [2] == [7]
6_2 이 성립하려면 : 6_1이 성립하고, [1] == [7]
7_1 이 성립하려면 : [0] == [7]

1. n_k 가 성립하려면, n_1 부터 차례대로 성립해야한다.

aaaaca
5_1 은 성립해도, 4_1과 4_2는 성립하지 않을 수 있다.
acaacac
6_1 X
5_2 O
4_3 X
```
- 어느 정도 규칙성을 찾는 건가 싶었지만, 명료하게 정리되지 않았고, 인덱스 하나하나마다 성립 여부를 따지기엔 n의 제한이 너무 컸다.
- **KMP의 실패 함수**를 사용했다. 최장 공통 접두사 / 접미사 길이를 이용한다면 더 쉽게 다가갈 수 있지 않을까 생각했다.

### KMP Table
|Index|String|i|
|---|---|---|
|0|b|0|
|1|a|0|
|2|b|1|
|3|a|2|
|4|b|3|
|5|a|4|
|6|b|5|
|7|a|6|

- P_8 인 babababa 경우 부터 살펴보면 , KMP Table 값은 6이다. 즉 **bababa**ba 와 ba**babababa** 에서 접두사 접미사 공통 부분의 길이가 6이 된다. 그렇다면, **bababa**ba 를 자세히 보자. **접두사의 앞 2글자 ba와, 접두사가 아닌 남은 2글자 ba가 같다는 것이 성립되면, 추정할 수 있는 가장 긴 주기가 bababa 가 될 수 있다!** (접두사에서 남은 baba 는 버려도 무관하기 때문에)
- 접두사 앞 k글자와 접두사가 아닌 나머지 k글자가 같다는 것을 성립하기 위해, **실패 함수를 탐색할 것이다.** 가장 긴 접두사 / 접미사 공통 부분에서 시작해서 다음 접두사 / 접미사 공통 부분을 알 수 있는 `i = table[i-1]` 을 계속 하다보면 6 -> 4 -> 2 -> 0 순으로 탐색이 되는데, 탐색 과정에서 2가 발견되었기에 접두사 앞 2글자와 접두사가 아닌 나머지 2글자가 같다는 것을 알 수 있다!

---

- 하지만 발견하지 못하는 경우도 있다. P_7 인 bababab 경우를 살펴보면, KMP 테이블 값은 5이고, 5 -> 3 -> 1 -> 0 순으로 탐색이 되는데, 2가 발견되지 않아 나머지 2글자가 접두사 앞 2글자와 성립하지 않는다. 이 경우는 어떻게 해야할까?
- 답은 간단하다. 탐색 과정에서 3을 발견했는데, 접두사 접미사 길이가 3이라고 했을 때 접두사 접미사 길이의 합이 P_7 경우의 문자열 길이의 7을 넘지 않으므로, **접두사 앞 3글자와 나머지 3글자가 같다고 볼 수 있다.** (**bab**a**bab**) 이 경우에서 주기는 4이다.
- 또한, 탐색 과정에서 1을 발견했는데, 접두사 접미사 길이가 1이라고 했을 때 접두사 접미사 길이의 합이 P_7 경우의 문자열 길이의 7을 넘지 않으므로, **접두사 앞 1글자와 나머지 1글자가 같다고 볼 수 있다.** (**b**ababa**b**) 이 경우에서 주기는 6이다. **가장 짧은 접두사 / 접미사 공통 부분이 가장 긴 주기를 만들어냈다!**

> 정리하자면, P_i 에서 추정할 수 있는 주기 중 가장 긴 주기를 구하려면, **(i - 가장 짧은 접두사 접미사 공통 부분의 길이)** 가 답이 된다. (단, 주기는 0보다 길다)

```py
table = [0 for _ in range(len(s))]
i = 0
for j in range(1, len(s)):
    while i > 0 and s[i] != s[j]:
        i = table[i-1]
    if s[i] == s[j]:
        i += 1
        table[j] = i
print(table)

ans = [0 for _ in range(n)]
for i in range(1, n):
    now_i = table[i]
    while now_i != 0 and table[now_i-1] != 0:
        now_i = table[now_i-1]
    ans[i] = ((i + 1) - now_i if now_i > 0 else 0)
print(ans)
```

```
8
babababa
[0, 0, 1, 2, 3, 4, 5, 6] # table
[0, 0, 2, 2, 4, 4, 6, 6] # ans
```

- n의 길이가 길어질수록, `now_i = table[now_i-1]` 로 테이블을 탐색하는 과정에서 중복되는 연산이 많아질 것이다. **따라서 kmp 테이블에서 더 빠른 탐색을 위해 값을 덮어쓰기 하면 연산 횟수를 줄일 수 있다!** 

## 첫 번째 풀이 (맞았습니다)
```py
# 1787 : 문자열의 주기 예측
import sys
input = sys.stdin.readline

n = int(input().rstrip())
s = input().rstrip()

# KMP table
table = [0 for _ in range(len(s))]
i = 0
for j in range(1, len(s)):
    while i > 0 and s[i] != s[j]:
        i = table[i-1]
    if s[i] == s[j]:
        i += 1
        table[j] = i
print(table)

ans = 0
for i in range(1, n):
    now_i = table[i]
    while now_i != 0 and table[now_i-1] != 0:
        now_i = table[now_i-1]
        table[i] = now_i
    ans += ((i + 1) - now_i if now_i > 0 else 0)
print(ans)
```

- `table[i] = now_i` 를 이용해, 이후 동일한 인덱스를 탐색할 때 빠르게 탐색할 수 있도록 동적 최적화를 했다.

## 평가
- 이걸 자력솔한 나 자신이 뿌듯하다! ㅎㅎ 비록 시간은 좀 오래 걸렸지만 말이다..
