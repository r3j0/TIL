## 2026-01-29 백준 문제 풀이

### [1911. 흙길 보수하기](https://www.acmicpc.net/problem/1911) (Gold 5)
```py
# 1911 : 흙길 보수하기
import sys
inpuyt = sys.stdin.readline

n, l = map(int, input().rstrip().split())
arr = [list(map(int, input().rstrip().split())) for _ in range(n)]
arr.sort(key=lambda x:x[0])

cnt = 0
start = -1
for i in range(n):
    if arr[i][0] < start: # 시작 지점을 포함하는 웅덩이
        arr[i][0] = start
    
    now_nul = (arr[i][1] - arr[i][0]) // l + (1 if (arr[i][1] - arr[i][0]) % l != 0 else 0)
    cnt += now_nul
    start = arr[i][0] + now_nul * l

print(cnt)
```

왼쪽부터 널빤지를 놓는다.

### [30993. 자동차 주차](https://www.acmicpc.net/problem/30993) (Silver 5)
```py
# 30993 : 자동차 주차
import sys
import math
input = sys.stdin.readline

n, a, b, c = map(int, input().rstrip().split())
print(math.comb(n, a) * math.comb(n-a, b))
```

동일 색 여러 차 들을 주차하는 경우의 수를 계산한다.

### [1504. 특정한 최단 경로](https://www.acmicpc.net/problem/1504) (Gold 4)
```py
# 1504 : 특정한 최단 경로
import sys
import heapq
input = sys.stdin.readline

n, e = map(int, input().rstrip().split())
edges = [[] for _ in range(n+1)]
for _ in range(e):
    a, b, c = map(int, input().rstrip().split())
    edges[a].append([b, c])
    edges[b].append([a, c])

ve1, ve2 = map(int, input().rstrip().split())

def dijkstra(start, end):
    global n
    distance = [float('inf') for _ in range(n+1)]
    distance[start] = 0

    q = []
    heapq.heappush(q, [0, start])

    while q:
        now_distance, now_destination = heapq.heappop(q)
        if distance[now_destination] < now_distance: continue

        for next_destination, next_distance in edges[now_destination]:
            new_distance = now_distance + next_distance
            if new_distance < distance[next_destination]:
                distance[next_destination] = new_distance
                heapq.heappush(q, [new_distance, next_destination])

    return distance[end]

res = min(dijkstra(1, ve1) + dijkstra(ve2, n), dijkstra(1, ve2) + dijkstra(ve1, n)) + dijkstra(ve1, ve2)
print(res if res != float('inf') else -1)
```

다익스트라로 풀이했다.

### [13565. 침투](https://www.acmicpc.net/problem/13565) (Silver 2)
```py
# 13565 : 침투
import sys
from collections import deque
input = sys.stdin.readline

m, n = map(int, input().rstrip().split())
maps = [list(map(int, list(input().rstrip()))) for _ in range(m)]

queue = deque()
vis = [[False for _ in range(n)] for _ in range(m)]
for i in range(n):
    if maps[0][i] == 0:
        queue.append([0, i])
        vis[0][i] = True

dy = [-1, 1, 0, 0]
dx = [0, 0, -1, 1]
while queue:
    now = queue.popleft()
    for d in range(4):
        ny = now[0] + dy[d]
        nx = now[1] + dx[d]

        if 0 <= ny < m and 0 <= nx < n and maps[ny][nx] == 0 and vis[ny][nx] == False:
            queue.append([ny, nx])
            vis[ny][nx] = True

print('YES' if vis[m-1].count(True) else 'NO')
```

BFS 로 풀이했다.
