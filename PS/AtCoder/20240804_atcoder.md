# AtCoder Training / A ~ D 1 Set 
**( AtCoder Beginner Contest 365 )** Date : 2024.08.04

## [A - Leap Year](https://atcoder.jp/contests/abc364/tasks/abc365_a)
## [B - Second Best](https://atcoder.jp/contests/abc364/tasks/abc365_b)

단순 구현 / 정렬로 풀이했다.


## [C - Transportation Expenses](https://atcoder.jp/contests/abc364/tasks/abc365_c)
```py
# C - Transportation Expenses
import sys
input = sys.stdin.readline

n, m = map(int, input().rstrip().split())
arr = list(map(int, input().rstrip().split()))
start = 0
end = max(arr)+1
while start + 1 < end:
  mid = (start + end) // 2
  now = 0
  for k in range(n):
    now += min(arr[k], mid)

  if now > m:
    end = mid
  else:
    start = mid

if start == max(arr): print('infinite')
else: print(start)
```

매개 변수 탐색으로 풀이했다.

## [D - AtCoder Janken 3](https://atcoder.jp/contests/abc364/tasks/abc365_d)
```py
# D - AtCoder Janken 3
import sys
input = sys.stdin.readline

n = int(input().rstrip())
s = input().rstrip()

# 타카하시는 아오키에게 이기거나 비겨야함.
# 타카하시는 다음 걸 다르게 내야 함.
dp = [[0, 0, 0] for _ in range(n+1)]

for i in range(n):
  if s[i] == 'R': # R 비김, S 짐, P 이김
    dp[i][0] = max(dp[i-1][1], dp[i-1][2])
    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + 1
  elif s[i] == 'S': # R 이김, S 비김, P 짐
    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + 1
    dp[i][1] = max(dp[i-1][0], dp[i-1][2])
  elif s[i] == 'P': # R 짐, S 이김, P 비김
    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + 1
    dp[i][2] = max(dp[i-1][0], dp[i-1][1])

print(max(dp[n-1]))
```

DP 로 풀이했다.

## [E - Xor Sigma Problem](https://atcoder.jp/contests/abc364/tasks/abc365_e)
[13710 : XOR 합 3 ( GOLD 1 )](https://www.acmicpc.net/problem/13710) 과 문제가 비슷하다.
[2830 : 행성 X3 ( GOLD 3 )](https://www.acmicpc.net/problem/2830) 문제에서 풀이 힌트를 얻을 수 있다.

