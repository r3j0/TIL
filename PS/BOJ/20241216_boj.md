# 백준 문제 풀이
Date : 2024.12.16

## [17265 : 나의 인생에는 수학과 함께 ( GOLD 5 )](https://www.acmicpc.net/problem/17265)
```py
# 17265 : 나의 인생에는 수학과 함께
import sys
input = sys.stdin.readline

n = int(input().rstrip())
maps = [list(input().rstrip().split()) for _ in range(n)]

on = 0
maxv = 0
minv = 0

def backtracking(now, now_pos, pre_op):
    global on
    global maxv
    global minv
    if now_pos == [0, 0]:
        now = int(maps[now_pos[0]][now_pos[1]])
    else:
        if maps[now_pos[0]][now_pos[1]] in ['+', '-', '*']:
            pre_op = maps[now_pos[0]][now_pos[1]]
        else:
            now = eval(str(now) + pre_op + maps[now_pos[0]][now_pos[1]])

    if now_pos == [n-1, n-1]:
        if on == 0:
            on = 1
            maxv = now
            minv = now
        else:
            maxv = max(maxv, now)
            minv = min(minv, now)
        return
    

    if now_pos[0] != n - 1:
        backtracking(now, [now_pos[0]+1, now_pos[1]], pre_op)
    if now_pos[1] != n - 1:
        backtracking(now, [now_pos[0], now_pos[1]+1], pre_op)

backtracking(0, [0, 0], '')
print(maxv, minv)
```

N의 제한이 작아서 백트래킹으로 풀이했다.
