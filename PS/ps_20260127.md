## 2026-01-27 백준 문제 풀이

### [34704. 크기가 4인 박스](https://www.acmicpc.net/problem/34704) (Silver 5)
```py
# 34704 : 크기가 4인 박스
import sys
input = sys.stdin.readline

n = int(input().rstrip())
arr = list(map(int, input().rstrip().split()))

first = arr.count(4) + arr.count(3) + (arr.count(2) // 2 + (1 if arr.count(2) % 2 else 0))
last_one = max(0, arr.count(1) - arr.count(3) - ((arr.count(2) % 2) * 2))
print(first + last_one // 4 + (1 if last_one % 4 else 0))
```

- 크기가 4인 물건은 하나의 박스에
- 크기가 3인 물건은 크기가 1인 물건과 함께 하나의 박스에
- 크기가 2인 물건은 하나의 박스에 2개씩. 크기가 2인 물건이 하나 남는다면 크기가 1인 물건과 함께 하나의 박스에

세 가지 경우를 고려해서 필요한 박스의 최소 개수를 출력했습니다.

### [1612. 가지고 노는 1](https://www.acmicpc.net/problem/1612) (Gold 5)
```py
# 1612 : 가지고 노는 1
import sys
input = sys.stdin.readline

n = int(input().rstrip())

if n == 1: print(1)
elif (n % 10) in [1, 3, 7, 9]:
    now_j = 1
    sums = 11 % n

    while sums != 0:
        now_j += 1
        sums = (sums * 10 + 1) % n

    print(now_j + 1)
else: print(-1)
```

처음엔 1로만 이루어진 수를 1, 10, 100, 1000 ... 과 같이 분해해서 n으로 나눈 나머지를 합했을 때 0이 되는 순간을 캐치하려고 했으나, 계산이 누적되며 시간 초과가 발생했습니다. 검색해보니 `1111.. % n` 을 계산한 다음 다시 `*10 + 1) % n` 을 해주면 합동식의 성질에 의해 결과가 같음을 알 수 있었습니다. 

> 나중에 공부해 볼 것
> - 합동식의 성질
> - 비둘기집 원리

### [2583. 영역 구하기](https://www.acmicpc.net/problem/2583) (Silver 1)
```py
# 2583 : 영역 구하기
import sys
from collections import deque
input = sys.stdin.readline

m, n, k = map(int, input().rstrip().split())
maps = [[False for _ in range(m)] for _ in range(n)]
for _ in range(k):
    lx, ly, rx, ry = map(int, input().rstrip().split())
    for i in range(lx, rx, 1):
        for j in range(ly, ry, 1):
            maps[i][j] = True
    
vis = [[False for _ in range(m)] for _ in range(n)]
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
cnt = 0
ans = []

for i in range(n):
    for j in range(m):
        if maps[i][j] == False and vis[i][j] == False:
            vis[i][j] = True
            cnt += 1

            s = 1
            queue = deque()
            queue.append([i, j])
            while queue:
                now = queue.popleft()
                for d in range(4):
                    nx = now[0] + dx[d]
                    ny = now[1] + dy[d]

                    if 0 <= nx < n and 0 <= ny < m and maps[nx][ny] == False and vis[nx][ny] == False:
                        s += 1
                        vis[nx][ny] = True
                        queue.append([nx, ny])
            
            ans.append(s)

ans.sort()
print(cnt)
print(' '.join(map(str, ans)))
```

기본 BFS 로 풀이했습니다.

### [1715. 카드 정렬하기](https://www.acmicpc.net/problem/1715) (Gold 4)
```py
# 1715 : 카드 정렬하기
import sys
import heapq
input = sys.stdin.readline

n = int(input().rstrip())
arr = [int(input().rstrip()) for _ in range(n)]

q = []
for i in range(n): heapq.heappush(q, arr[i])

ans = 0
while len(q) > 1:
    first = heapq.heappop(q)
    second = heapq.heappop(q)
    heapq.heappush(q, first + second)
    ans += first + second

print(ans)
```

처음엔 단순 그리디로 풀이하려고 했으나, 무조건 작은 카드부터 합해가는 것이 아닌 아예 합하지 않은 다른 두 카드를 먼저 합하는 것이 유리할 수도 있다는 직관을 얻어, 우선순위 큐로 풀이했습니다.

### [14925. 목장 건설하기](https://www.acmicpc.net/problem/14925) (Gold 4)
```py
# 14925 : 목장 건설하기
import sys
input = sys.stdin.readline

m, n = map(int, input().rstrip().split())
maps = [list(map(int, input().rstrip().split())) for _ in range(m)]

ans = 0
dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
for i in range(1, m+1):
    for j in range(1, n+1):
        if maps[i-1][j-1] == 0:
            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        else: dp[i][j] = 0

        ans = max(ans, dp[i][j])

print(ans)
```

2차원 DP 를 활용해 현재 타일에서 얻을 수 있는 가장 큰 정사각형 목장의 크기를 유지했습니다.

## DP 문제 풀이

### [2839. 설탕 배달](https://www.acmicpc.net/problem/2839) (Silver 4)
```py
# 2839 : 설탕 배달
import sys
input = sys.stdin.readline

n = int(input().rstrip())
k5 = n // 5
last = n % 5
while k5 > 0 and last % 3 != 0:
    k5 -= 1
    last += 5


print(k5 + last // 3 if last % 3 == 0 else -1)
```

그리디로 풀이했습니다.

### [1463. 1로 만들기](https://www.acmicpc.net/problem/1463) (Silver 3)
```py
# 1463 : 1로 만들기
import sys
input = sys.stdin.readline

n = int(input().rstrip())
dp = [float('inf') for _ in range(n+1)]
dp[n] = 0

for i in range(n, 1, -1):
    if i % 3 == 0: dp[i//3] = min(dp[i//3], dp[i] + 1)
    if i % 2 == 0: dp[i//2] = min(dp[i//2], dp[i] + 1)
    dp[i-1] = min(dp[i-1], dp[i] + 1)

print(dp[1])
```

DP로 풀이했습니다.

### [9095. 1, 2, 3 더하기](https://www.acmicpc.net/problem/9095) (Silver 3)
```py
# 9095 : 1, 2, 3 더하기

dp = [0 for _ in range(12)]
dp[1] = 1
dp[2] = 2
dp[3] = 4
for i in range(4, 12):
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

import sys
input = sys.stdin.readline

t = int(input().rstrip())
for _ in range(t):
    print(dp[int(input().rstrip())])
```

DP 전처리를 사용했습니다. 점화식은 `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`
