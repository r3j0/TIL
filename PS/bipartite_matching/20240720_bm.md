# 이분 매칭 문제 풀이
Date : 2024.07.20

## [1671. 상어의 저녁식사 ( PLATINUM 3 )](https://www.acmicpc.net/problem/1671)
```py
# 1671 : 상어의 저녁식사 ( PLATINUM 3 )
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10000)

n = int(input().rstrip())
info = [list(map(int, input().rstrip().split())) for _ in range(n)]

graph = [list() for _ in range(n)]
for i in range(n-1):
  for j in range(i+1, n):
    if info[i][0] >= info[j][0] and info[i][1] >= info[j][1] and info[i][2] >= info[j][2]:
      graph[i].append(j)
    elif info[i][0] <= info[j][0] and info[i][1] <= info[j][1] and info[i][2] <= info[j][2]:
      graph[j].append(i)

selected = [-1 for _ in range(n)]
visited = [0 for _ in range(n)]

def bimatch(now, first):
  if visited[now] == 1: return False
  visited[now] = 1

  for go in graph[now]:
    if go == first: continue
    if (selected[go] == -1 or bimatch(selected[go], i)):
      selected[go] = now
      return True
  return False

res = 0
for k in range(2):
  for i in range(n):
    visited = [0 for _ in range(n)]
    if bimatch(i, i): res += 1
print(n - res)
```

이분 매칭을 통해 풀이했다. 능력치가 똑같은 상어는 서로를 잡아먹을 수 있다는 문제가 있는데, 한 상어가 다른 상어를 잡아먹도록 (쌍방향이 일어나지 않도록) 처리해준다. 능력치가 똑같은 상어끼리는 임의로 한 상어가 다른 상어를 잡아먹게 해도 어차피 같은 능력치이기 때문에 다른 상어 하나를 못 잡아 먹는 등의 낭비가 발생하지 않는다.

## [1867. 돌멩이 제거 ( PLATINUM 3 )](https://www.acmicpc.net/problem/1671)
```py
# 1867 : 돌멩이 제거 ( PLATINUM 3 )
import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)

n, k = map(int, input().rstrip().split())
graph = [[] for _ in range(n)]
for i in range(k):
  a, b = map(int, input().rstrip().split())
  graph[a-1].append(b-1)

selected = [-1 for _ in range(k)]
visited = [0 for _ in range(n)]

def bimatch(now):
  if visited[now] == 1: return False
  visited[now] = 1

  for go in graph[now]:
    if (selected[go] == -1 or bimatch(selected[go])):
      selected[go] = now
      return True
  return False

res = 0
for i in range(n):
  visited = [0 for _ in range(n)]
  if bimatch(i): res += 1
print(res)
```

쾨닉의 정리를 이용한 문제라고 한다.
한 돌멩이를 어떻게 선택할지 보다는, 행 -> 열 그래프를 만들어서 한 행 정점이 다른 열 정점을 선택하여 최대 이분 매칭 횟수를 센다면, **연결된 행 정점과 열 정점이 커버하지 않는 정점이 없도록, 최소 버텍스 커버를 구할 수 있어 문제의 답을 만족한다.**  
풀이는 [이 블로그](https://byeo.tistory.com/entry/boj1867-%EB%8F%8C%EB%A7%B9%EC%9D%B4-%EC%A0%9C%EA%B1%B0)를 참조했다.  
[쾨닉의 정리](https://gazelle-and-cs.tistory.com/12)를 공부해야 한다.
