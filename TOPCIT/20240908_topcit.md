# 1-4. 소프트웨어 설계 원리와 구조적 설계
분석 및 설게 단계에서 품질 관리와 예방 활동을 강화할수록 소프트웨어의 실패 비용을 크게 졸일 수 있다.

## 01. 소프트웨어 설계 원리
### 소프트웨어 설계 원리 : 추상화, 정보 은닉, 단계적 정제, 모듈화, 구조화
### 응집도 종류 (강한 순서부터) : 기능적, 순차적, 교환적(통신적), 절차적, 시간적, 논리적, 우연적 (기순교 절시논우)
### 결합도 종류 (약한 순서부터) : 자료, 스탬프, 제어, 외부, 공통, 내용 (자스제 외공내)

<details>

- 분할과 정복 : 설계 단계에서 요구사항을 지속적으로 분할해 복잡성을 줄여나가고, 적절한 그룹으로 재조합되어야 한다. 
- 상위시스템에서 분할한 시스템 구성 요소는 서브시스템 (독립적으로 기능을 수행하고 컴파일되는 프로그램 구성 요소) 이고, 서로 다른 개발자들에 의해 개발되어 통합된다.
- 추상화 : 상위 수준에서 제품 구현을 먼저 생각하는 것. (자료 추상화, 제어 추상화, 과정 추상화) 컴포넌트의 구현 방법을 과감히 생략하고 외부 인터페이스에 초점을 맞추는 것
- 정보 은닉 : 각 모듈 내부 내용을 감추고 인터페이스를 통해 메시지를 전달할 수 있는 개념. **변경 발생 시 영향이 최소한의 모듈에만 미치도록 함.**
- 단계적 정제 : 프로그램 구조 -> 모듈에 대한 세부 사항으로 내려가며 구체화. 하나씩 쪼개져 세부기능을 수행하는 프로세스로 나누어 감.
- 모듈화 : 시스템을 구성 요소로 나누어 접근. (서브루틴, 프로시저, 함수) 하향식 접근 방법으로 기능 단위로 쪼갬. **모듈 수가 증가하면 모듈 크기 감소 및 모듈 간 상호 교류가 증가해 시스템 성능이 떨어지고 과부화가 나타남.**
- 구조화 : 분할 과정에서 요구사항 분석 및 설계로 넘어가며 중요 요소나 기능을 찾아내 구조화.
- **기능적 독립성은 극대화. 모듈들 사이의 결합을 줄이는 게 유지보수가 쉬워짐.**
- 응집도 : 모듈 내부가 얼마나 강하게 뭉쳤는지. 모듈은 하나의 논리적 기능을 수행하는 것이 바람직. **모듈 응집도를 높이면 모듈 사이 낮은 결합도(바람직함). 모듈 응집도가 낮으면 모듈 사이 높은 결합도.**
- 기능적 응집도 (Functional Cohesion) : 모듈 내부 모든 기능 요소가 단일한 목적을 위해 수행되는 경우
- 순차적 응집도 (Sequential Cohesion) : 한 활동으로부터 나온 출력값을 다른 활동에 사용할 경우
- 교환적(통신적) 응집도 (Communication Cohesion) : 동일한 입출력을 사용하여 서로 다른 기능을 수행하는 활동들이 모인 경우
- 절차적 응집도 (Procedural Cohesion) : 다수 관련 기능을 가질 때 그 기능을 순차적으로 수행하는 경우
- 시간적 응집도 (Temporal Cohesion) : 연관된 기능은 아니여도 특정 시점에 처리되어야 하는 활동들을 한 모듈에서 처리 하는 경우
- 논리적 응집도 (Logical Cohesion) : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우
- 우연적 응집도 (Coincidental Cohesion) : 연관 없는 경우
- 결합도 : 다른 모듈들과 연관 관계. 상호 교류가 많고 의존이 많을수록 결합도가 높음. 모듈 간 매개변수로 통신하는 자료결합이 가장 이상적이고 유지보수하는 게 쉽고, 다른 모듈의 내부 기능 및 자료를 직접 참조 및 수정하면 파문 효과(Ripple Effect)를 일으키고 유지보수하기 어려워진다. 전역 변수를 쓰지 않고 매개 변수를 써야 결합도를 낮춘다.
- 파문 효과 : 하나에 영향이 생기면 다른 많은 것에 영향을 끼침.
- 자료 결합도 (Data Coupling) : 파라미터를 통해서만 상호작용
- 스탬프 결합도 (Stamp Coupling) : 인터페이스로 배열, 오브젝트, 스트럭처가 전달 (자료 구조 형태 변경 시 참조하는 모듈에 영향)
- 제어 결합도 (Control Coupling) : 값 전달 뿐만 아니라 어떻게 처리해야 한다는 제어 요소가 전달되는 경우 (파라미터 값에 따라 모듈 내부 로직이 달라지는)
- 외부 결합도 (External Coupling) : 다수 관련 기능을 가지고 순차적으로 수행할 경우, 특수 외부환경에 종속 및 연관될 경우
- 공통 결합도 (Common Coupling) : 전역 변수 참조 및 갱신. (공통 데이터 영역 사용. 모든 모듈에 영향 미치므로 독립성 약해짐)
- 내용 결합도 (Content Coupling) : 다른 모듈 변수나 기능 사용. 한 모듈에서 다른 모듈의 중간으로 분리되는 경우

</details>

## 03. 구조적 설계 방법
### 주요 키워드 : 자료흐름 중심 설계, 변환흐름 중심 설계, 트랜잭션흐름 중심 설계

<details>

- 자료흐름 중심 설계 : 구조적 분석의 결과를 구조적 설계로 옮기는 과정. 시스템을 분할하고 하향식(탑다운)으로 세분화.
- 구조적 분석에서 사용하는 표기법 : 버블차트, 자료흐름도(DFS; Data Flow Diagram)
- 구조적 설계에서 사용하는 표기법 : 구조도표 (Structure Chart)
- 구조도표 : 프로그램 구조를 나타내고, 자료와 제어 흐름, 반복 선택과 같은 제어 구조, 모듈 간 자료와 제어 정보 교환, 주요 루프, 의사 결정 등을 나타냄
- 구조적 설계는 요구사항 명세서를 설계 문서로 바꾸며, 분석에서 설계로 이동할 때 변환기초 - 트랜잭션기초 유형의 특성을 이용해 설게 문서를 만듬.
- 변환흐름 중심 설계 (Transform Flow-Oriented Design) : 정보 처리 및 출력 시스템을 합당한 컴퓨터 구조로 매핑. 입력을 받아들여 시스템에 사용될 데이터로 정제하는 프로세스인 입력흐름 (Incoming Flow), 데이터를 가공 처리하는 변환흐름 (Transform Center), 출력하는 출력흐름 (Outgoing Flow)
- 변환에 기초한 프로그램 구조를 만들기 위해 자료흐름도의 입력흐름, 변환흐름, 출력흐름을 규명하는 게 기초. 입력 제어 모듈, 변한 제어 모듈, 출력 제어 모듈로 나누어짐
- 입력제어모듈 (Input Controller) 은 하위 모듈에서 입력 데이터를 받아들여 상위로 정제 후 보냄. 출력제어모듈 (Output Controller) 는 상위로부터 출력 데이터를 받아 정제 후 하위로 보냄. 전체모듈 (Overall Controller)에서 입력제어모듈, 변환제어모듈 (Transform Controller), 출력 제어 모듈이 연결된 프로그램 구조
- 트랜잭션 : 자료나 제어 시그널이 어떠한 행위를 유발 시키는 것. 
- 트랜잭션흐름 중심 설계 (Transaction Flow-Oriented Design) : 입력값을 평가하고 그 결과에 따라 여러 출력 경로 중 하나를 따라 흘러감. 하나의 입력 경로와 여러 출력 경로를 가지고 각 동작 경로는 여러 버블로 구성될 수 있으며 변환 흐름이나 트랜잭션 흐름을 가질 수 있음.
- 트랜잭션 구조의 세 구성 요소 : 트랜잭션 중심으로 작용하는 모듈 (전체 제어), 입력을 받아들이는 모듈 (입력 제어), 각 동작 경로에 해당하는 하나 이상의 모듈(트랜잭션 제어)
- 각 동작 경로는 여러 버블로 구성될 수 있고. 변환 흐름이나 트랜잭션 흐름을 가질 수 있다.
- **변환흐름 중심 설계가 전체모듈에서 입력제어 모듈, 변환제어 모듈, 출력제어 모듈이 연결된 구조였다면 트랜잭션흐름은 전체제어에서 입력제어, 트랜잭션제어로 유입경로(Reception path) 로 이어져 있으며, 트랜잭션 제어에서 동작경로(Action path)로 다른 모듈과 이어져 있다.

</details>

## 1-5. 소프트웨어 아키텍처 설계
소프트웨어 아키텍처는 고품질 SW를 효과적으로 개발하기 위해 기초적이고 유용한 핵심적인 역할을 한다. **아키텍처 설계는 설계 프로세스 초기에 시스템이 어떻게 구성되는지, 구성 요소들 사이에 어떻게 상호 작용하는지 규명하고 시스템의 복잡도를 관리하기 위해 필수적으로 요구되는 단계이다.**

### 01. 소프트웨어 아키텍처 설계
### 소프트웨어 아키텍처 설계 절차 : 요구사항분석, 아키텍처 분석 및 설계, 아키텍처 검증 및 승인

<details>

- Creating Vision (비전 제시자) : 제품에 대한 전문적 시작과 경험으로 요구사항과 제약사항을 잘 파악하고, 소프트웨어의 틀을 완성하는 역할로써 창의력과 전달력이 중요함.
- Key Technical Consultant (기술 자문가) : 개발조직에 대한 기술적 조언. 디자인 패턴 및 개발 프레임워크 선정 등 매우 중요한 단계이며 이를 위한 지속적인 지식의 현행화 및 역량개발이 필요함.
- Makes Decisions (의사 결정자) : 전체 설계를 리딩하고 중요한 영역 결정을 함. 지식의 함양과 애자일 개발 등과 같이 상황에 맞는 적절하고 신속한 의사결정 역할이 중요해짐.
- Coaches (코치) : 아키텍쳐 교육, 개선처리, 피드백
- Coordinates (조정자) : 참여자 간 이견 조정 및 중재. 기술적 역량 외 의사소통 역량 중요.
- Implements (구현가) : 새 기술 도입 시 설계단계부터 영향도를 평가, 프로토타입으로 구현가능성 평가. 기술과 경험을 높여 아키텍트로 성장함.
- Advocates (대변가) : 지속적인 새로운 아키텍처 평가, 도입, 투자 근거 제공, 기술역량 및 아키텍처 고도화
- 소프트웨어 아키텍처 : SW 개발에 직간접적으로 영향을 미치고 복잡도를 높이는 다양한 요소들을 체계적으로 다루기 위한 개발 대상 소프트웨어의 청사진. 의사소통 수단 및 프로젝트 초기 의사결정 도구로 활용되며 시스템 전체 구조 및 개발 프로젝트 조직 결정 시 참조된다.
- Booch : 소프트웨어 구조에 대한 중요한 의사결정의 집합으로 아키텍처를 정의함.
- Myron Ahn : 모듈, 프로세스, 데이터, 이들의 구조, 구성 요소들 간의 관계, 이러한 구성요소와 관계가 어떻게 확장 및 수정되는지, 사용 기술은 어떻고 소프트웨어 아키텍처를 통해 시스템의 유연성과 성능, 시스템을 어떻게 구현하고 수정할 수 있는지를 판단할 수 있다.
![.](https://velog.velcdn.com/images/e_juhee/post/8a5212d3-12f9-422d-837a-171a3a22b062/image.png)
- Architectural Description (아키텍처 명세서) : 아키텍처를 기록하기 위한 산출물들 (아키텍처는 명세서에 의해 묘사됨. 아키텍처 명세서는 근거를 제공, 이해관계자들은 명세서를, 뷰는 명세서의 의해 구성, 모델은 명세서를 모음)
- Stakeholder (이해관계자) : 관련된 모든 사람과 조직. (관심사가 중요. 산출물 명시. 시스템은 이해관계자를 지님. 관점에 집중)
- Concern (관심사) : 이해관계자들의 서로 다른 의견과 목표. (관심사가 명세서에 명시. 관점 커버에 사용. 관심사는 이해관계자를 가짐.)
- Viewpoint (관점) : 개별 뷰를 개발할 때 패턴이나 양식, 산출물들에 대해 이해관계자들이 보고 싶은 관점
- View (뷰) : 서로 관련 있는 관심사들의 집합이라는 관점에서 전체 시스템 표현.
- Rationale (근거) : 아키텍처 결정 근거
- Mission (목표) : 이해관계자들이 의도하는 목적, 사용, 운영방법
- 서브시스템 (Subsystem) : 상위 레벨에서 분할한 시스템 구성 요소. 자료와 제어구조를 포함하고, 독립적으로 기능을 수행하고 컴파일 될 수 있는 프로그램 구성요소임.
- 프레임워크 (Framework) : 서브시스템 설계 시 반복적 반영 가능한 자원 단위. 구체적인 서브시스템을 위해 확장될 수 있는 일반 구조. 구체적인 구현 방법 등을 제공해 설계 추상화 수준 높임.
- **아키텍처 설계는 요구사항 만족을 위해 시스템 구성을 설정하는 프로세스이다. 요구사항 분석 과정 결과로 각 구성 요소(모듈)들 사이 관계를 기술한다. 주목적은 모듈화된 프로그램 구조 개발 및 모듈 사이 제어 인터페이스를 나타내는 것이다.**

</details>

### 02. 소프트웨어 아키텍처 스타일
### 주요 키워드 : 저장소 구조, MVC 구조, 클라이언트-서버 모델, 계층 구조, 파이프 필터 구조

<details>

- 저장소 구조 : 한 서브시스템에서 생성한 데이터를 다른 서브시스템들이 사용. 모든 공유 데이터를 한 곳에 보관한다. (다량의 데이터 공유에 적합)
- MVC (Model-View-Controller) 구조 : GUI 설계에 많이 활용되는 프레임워크 : 한 객체 표현이 수정되면 다른 모든 표현도 따라서 갱신. 수정이 단순화되고 재사용 수월
- 클라이언트-서버 모델 : 서버와 클라이언트 집합으로 구성되는 모델. 여러 클라이언트 인스턴스가 있음. 분산 시스템이라 네트워크 시스템 효과적 사용 가능
- 계층 구조 : 시스템을 여러 계층으로 구성해 특정 서비스를 계층마다 제공. 문제 해결이 쉬워짐. 국제표준기구 ISO에서 개발한 OSI 7계층이 대표적인 계층 구조

</details>

### 03. 소프트웨어 아키텍처 설게 표현 방법
### 주요 키워드 : 컨텍스트 모델, 컴포넌트 다이어그램, 패키지 다이어그램, 배치 다이어그램 

<details>

- 컨텍스트 모델 :
- 컴포넌트 다이어그램 :
- 패키지 다이어그램 :
- 배치 다이어그램 : 

</details>

# 3-1. 시스템 개념
빅데이터, 클라우드 컴퓨팅, IoT 신기술들이 주목받으며 시스템아키텍처는 점점 복잡해지고 있다. 서버, 스토리지, 네트워크로 단순하게 구성된 시스템아키텍처는 신기술들의 요구사항 (고성능 컴퓨팅 파워, 고용량 메모리, 고속 통신속도) 에 맞춰 요건이 변경되고 있다. 이 변화에 맞춰 시스템아키텍처의 중요성도 높아져가고 있다.

