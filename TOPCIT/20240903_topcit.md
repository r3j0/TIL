# 소프트웨어 공학
### 주요 키워드 : 개발, 운용, 유지보수, 효율적 업무 지원, 소프트웨어 위기, 선코딩-후수정, 폭포수, 동시공학
### 소프트웨어 공학 3가지 요소 : 프로세스, 인력, 기반 인프라 기술
### 소프트웨어 공학 4가지 중요 요소 : 방법, 도구, 절차, 사람

<details>

- 소프트웨어 개발을 위해, 요구사항 분석부터 유지보수까지 전 과정에 걸쳐 예상되는 어려움을 해결하기 위한 체계적 관리와 효율적 업무 수행 지원하는 기술, 기법
- 소프트웨어의 개발, 운용, 유지보수 등의 생명주기 전반을 체계적이고 서술적이며 정량적으로 다루는 학문

1. 프로세스 (Process) : 체계적 업무 방식 및 흐름의 정의, 이를 적용할 수 있는 프로세스
2. 인력 (People) : 전문적 지식을 갖춘 조직 및 인력
3. 기반 인프라 기술 (Technology) : 프로세스와 인력이 효율적으로 운영되기 위한 기술

이 3가지 요소를 균형 있고 조화롭게 유지하기 위한 지속적 노력이 필요함.

- 1950년대 : 소프트웨어 공학 개념 도입
- 1960년대 : 수요는 급증하지만 인력, 경력 부족으로 소프트웨어 위기 발생.
- 1970년대 : 비전공자 대거 투입. 선코딩-후수정 접근으로 많은 부작용 발생. 구조적 또는 정형적 기법들이 발생하고 **분석, 설계, 구현 등을 순차적으로 진행하는 폭포수 모델 개발**
- 1980년대 : 정형적 기법은 사용성이 떨어지고 폭포수는 비용 소모와 속도가 느리다는 점 인식. 재사용성을 높이기 위한 방법 연구
- 1990년대 : 시장 경쟁 우위 선점 위해 시장출시 기간 단축해야 해서 생산성 연구. **폭포수 모델에서 요구사항, 설계, 구현을 동시에 진행하는 동시공학(Concurrent Engineering)에 집중.**
- 2000년대 : 시장 환경 급격 변화에 효과적 대응을 위해 애자일 방법론 도입

4가지 중요요소를 통해 고품질 소프트웨어를 생산하고 주어진 비용과 일정에 딜리버리가 가능
1. 방법 : 프로젝트 계획 수립, 추정, 분석, 자료구조, 프로그램 구조, 알고리즘, 코딩, 테스팅, 유지 관리 등 작업들
2. 도구 : 생산성 혹은 일관성 목적으로 사용하는 방법들을 자동화, 반자동화 시켜 놓은 것. (요구 관리 도구, 모델링 도구, 형상관리 도구, 변경 관리 도구)
3. 절차 : 방법과 도구를 결합해 소프트웨어를 합리적이고 적시에 개발하도록 함. 방법들, 결과물, 제어들, 마일스톤 등의 순서 정의
4. 사람
</details>

# 소프트웨어 개발 생명주기
### 주요 키워드 : 소프트웨어 개발 모든 과정, 비용 산정 및 계획, 리스크 최소화
### 생명주기 구성 : 타당성 검토, 개발 계획, 요구사항 분석, 설계, 구현, 테스트, 운용, 유지보수

<details>

- 사용자 환경 및 문제점 이해부터, 운용/유지 보수까지 모든 과정.
- 타당성 검토 -> 개발 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 운용 -> 유지보수

목적 : 프로젝트 비용 산정, 계획 수립, 골격 구성, 용어 표준화

생명주기 선정 : 기업에서 개발 프로세스 테일러링하는데 중요. 개발의 리스크와 불확실성 및 이에 대한 이해 바탕으로 수행하며 최소화 시킬 수 있어야 함. 프로젝트 특성에 따라 생명주기 모델 변경 사용 가능.
</details>



# 소프트웨어 재사용 
### 주요 키워드 : 기존 지식 활용, 표준화, 생산성, 품질 향상
### 재사용 원칙 : 범용성, 모듈성, HW 독립성, SW 독립성, 자기 문서화, 일반성, 신뢰성

<details>

- 기존 소프트웨어, 기존 소프트웨어 지식을 활용해 새로운 소프트웨어를 구축하는 일
- 소프트웨어 개발관련 지식 (기능, 모듈, 구성 등) 을 표준화하여 생산성 높이고 반복 사용하기에 적합하도록 구성

배경 : 소프트웨어 위기로 인해 품질과 생산성이 저하되는 상황에서, CASE 도구 (자동화 도구) 사용에 필요하고, 개발 표준화 준수 및 품질확보를 위해 소프트웨어 재사용을 수행한다.

목적 : 사전 성능이 검증된 기존 소프트웨어들이고, 업그레이드가 용이하고, 비용 및 시간적인 개발 프로세스를 향상시키기 위함. (신뢰성, 확장성, 생산성)

대상 : 환경 정보, 외부 지식, 기본 설계(System Architecture), 상세 설계(System Design), 시스템 데이터,  시험 사례(Test Cases), 모듈, 프로그램, 투자 대 효과 분석정보(Cost Benefit Analysis), 사용자 지침서, 타당성 조사방법 및 결과(Feasibility Studies), 프로토타입, 인력

실무에서 문제점 : 공통으로 사용되는 모듈 발견하기가 어렵고, 표준화가 부족하다. 요구사항에 대한 이해가 곤란하고 개발비가 더 들 수 있다. 재사용한 효력은 오랜 시간이 경과 후 나타난다. 현존하는 소프트웨어에서 재사용 부품 추출이 쉽지 않다.

원칙 :
1. 범용성 (Generality) : 일반적으로 활용될 수 있어야 함
2. 모듈성 (Modularity) : 정보은닉, 추상화 원칙으로 최소 결합도 최대 응집력
3. 하드웨어 독립성 : 하드웨어 기종과 무관
4. 소프트웨어 독립성 : OS, DBMS와 무관
5. 자기 문서화 (Self Documentation) : 모듈 기능, 용법, 인터페이스 기술
6. 일반성 (Commonality) : 대다수에게 필요하고 사용 가능
7. 신뢰성 (Reliability)

장애요인 : 관리자와 개발 담당자들의 거부 반응, 동기 결여, 표준화가 되어 있지 않음. 사회적 또는 법적 장애

장애요인 제거 대책 : 새로운 설계, 개발 방법론 활용. 재사용 라이브러리 구축, 자동화 도구 활용, 보상제도 및 능동적 경영전략

고려사항 : 생산성 향상 가능한지, 체계화되었는지, 재사용 문화 조성, 초기 투자, 지속적 개선 및 보강, 생산성 평가 및 척도, 개발 접근법 등

효과 : 비용 절감, 품질 향상, 타 프로젝트 산출물 공유, 좋은 시스템 구축방법에 대한 교육적 효괴
</details>

# 역공학
### 주요 키워드 : 유지보수 단계, 효율 저하, 역추적, 처음 문서
### 역공학 종류 : 논리역공학, 자료역공학

<details>

- 이미 만들어진 시스템을 역으로 추적해 처음의 문서나 설계기법 등의 자료를 얻어 내는 일. 유지보수 단계에 수행한다.
- 유지보수 어려운 경우, 빈번한 변경으로 효율 저하, 재구축, 다운사이징 하는 경우 역공학을 하면 소프트웨어 분석을 돕고 유지 보수성을 향상시키고 자동화 도구의 사용 용이해짐.

1. 논리역공학 : 원시코드로부터 정보 추출 -> 물리적 설계 정보저장소에 저장한다. (물리적 설계정보)
2. 자료역공학 : 기존 DB를 수정하거나 새로운 DBMS로 전이하는 역할
</details>
  
# 자료구조

<details>

- 자료를 컴퓨터의 기억장치 내에 저장하는 방법
- 다양한 자료를 효율적으로 표현하고 활용하도록, 특성과 사용 용도를 고려해 조직적, 체계적으로 정의한 것

- 선형구조 : 원시코드로부터 정보를 추출해 물리적 설계 정보저장소에 저장. 직선 형태로 나열. 순서 고려. 전후/인접/선후 자료들 간 1:1 관계 나열. (배열, 선형리스트, 연결리스트, 스택, 큐, 데크)
- 비선형구조 : 한 자료 뒤에 여러 개의 자료들이 존재. 인접/전후 자료들 간 1:다 또는 다:다 관계로 배치 (트리, 그래프)

- 순차자료구조 : 연속 저장. 논리적 순서와 물리적 순서 일치. 배열 구현
- 연결자료구조 : 순서 상관없이 링크에 의한 논리적 순서 표현. 논리적 순서와 물리적 순서 일치하지 않음. 논리적 순서 변경되어도 링크정보만 변경되어 물리적 순서 변경X, 포인터 구현

- 스택 : push top, pop top
- 큐 : enQueue rear, deQueue, front
</details>

# 알고리즘
### 알고리즘의 조건 : 입력, 출력, 명확성, 유한성, 효과성
### 알고리즘 분석 기준 : 정확성, 작업량, 기억 장소 사용량, 최적성, 단순성
### 알고리즘 표현 방법 : 자연어 기술, 순서도 표현, 의사 코드
### 알고리즘 성능 분석 : 공간 복잡도 (고정 공간량 + 가변 공간량), 시간 복잡도 (컴파일 시간 + 실행시간)

<details>

- 주어진 문제를 해결하기 위한 일련의 처리 절차를 단계적으로 기술한 것.
- 문제 해결 방법을 추상화하여 단계적 절차를 논리적으로 기술한 명세서.

- 알고리즘의 조건 : 입력, 출력, 명확성, 유한성, 효과성
- 알고리즘 분석 기준 : 정확성, 작업량, 기억 장소 사용량, 최적성, 단순성
- 알고리즘 표현 방법 : 자연어 기술, 순서도 표현, 의사 코드
- 알고리즘 성능 분석 : 공간 복잡도 (고정 공간량 + 가변 공간량), 시간 복잡도 (컴파일 시간 + 실행시간)

- 내부정렬 : 소량 데이터를 주기억 장치에 올려 정렬. 속도는 빠르나 양 제한
- 외부정렬 : 대량 데이터를 보조기억 장치에 올려 정렬. 데이터를 서브 파일로 나누어 내부 정렬 후 보조기억장치에서 병합. 속도 느림

- 내부정렬 종류 : 삽입정렬, 쉘정렬 (삽입법), 선택정렬, 퀵정렬, 버블정렬 (교환법), 힙정렬 (선택법), 머지정렬 (병합법), 계수정렬, 기수정렬, 버킷정렬 (분배법)

- 쉘정렬 : 특정 매개변수 값 길이를 갖는 부파일(subfile)로 쪼개서 삽입정렬
- 퀵정렬 : 분할 정복으로 임의 기준 선택하여 작은 값 왼쪽, 큰 값 오른쪽 위치
- 힙정렬 : 최대 힙 트리, 최소 힙 트리로 정렬
- 기수정렬 : 데이터 낮은 자리 수부터 비교하여 정렬

- 피보나치탐색 : 피보나치 순열로 서브 파일을 형성해 가며 검색
- 보간탐색 : 예상 위치에서 선형 탐색
- 블록탐색 : 전체를 일정 개수 블록으로 구분하고 순차 검색
- 해싱 : 해싱 함수로 데이터 주소를 직접 계산하여 찾아감

- 크루스칼 : 가중치가 가장 낮은 간선을 선택한 후 순서대로 간선 선택
- 프림 : 한 정점을 선택해 MST 부분에 방문하지 않은 새로운 정점과 간선을 선택하여 확장
</details>
