# Minimum Spanning Tree (최소 스패닝 트리)
최소 스패닝 트리는, 그래프의 모든 정점을 사이클 없이 연결하면서, 모든 간선의 가중치 합이 최소가 되는 트리이다.

## 크루스칼 알고리즘
크루스칼 알고리즘의 주요 진행법은 다음과 같다.
1. 비용 기준으로 모든 간선을 오름차순 정렬한다. 
2. 제일 비용이 낮은 간선부터, 연결된 두 정점이 같은 그룹에 속해있는지 확인한다. (유니온 파인드를 이용한다.)
3. 다른 그룹이라면, 그 간선을 사용하여 두 정점 그룹을 연결한다. 이때 해당 간선의 비용이 추가된다.
4. 같은 그룹이라면, 다음 간선을 탐색한다.

```py
edge = [list(map(int, input().rstrip().split())) for _ in range(m)]

# Kruskal
edge.sort(key=lambda x:x[2])

parent = [i for i in range(n+1)]
def find(a):
    s = []
    while a != parent[a]:
        s.append(a)
        a = parent[a]
    end = a
    while s:
        now = s.pop()
        parent[now] = end
    return end

def union(a, b):
    a = find(a)
    b = find(b)

    if a != b:
        if a < b: parent[b] = a
        else: parent[a] = b
        return True
    return False

ans = 0
for u, v, c in edge:
    if union(u, v):
        ans += c

print(ans)
```

## 프림 알고리즘
프림 알고리즘의 주요 진행법은 다음과 같다.
1. 임의의 시작 정점 하나를 잡는다.
2. 탐색하려는 정점에 연결된 간선 모두를 우선순위 큐에 비용 기준으로 다음 정점과 함께 push 한다.
3. 우선순위 큐에서 pop한 정점이 아직 탐색되지 않았다면 해당 간선의 비용이 추가된다. 그리고 해당 정점에서 2번을 반복한다.
4. 우선순위 큐에서 pop한 정점이 이미 탐색되었다면 다음 우선순위 큐 항목을 탐색한다.

```py
# Prim
graph = [[] for _ in range(n+1)]
for _ in range(m):
    u, v, c = map(int, input().rstrip().split())
    graph[u].append([v, c])
    graph[v].append([u, c])

def prim(start):
    vis = [False for _ in range(n+1)]
    
    pq = []
    heapq.heappush(pq, [0, start])
    ans = 0
    cnt = 0
    while pq:
        if cnt == n: break
        now_cost, now_i = heapq.heappop(pq)
        
        if vis[now_i]: continue
        vis[now_i] = True
        ans += now_cost
        cnt += 1

        for next_i, next_cost in graph[now_i]:
            if not vis[next_i]:
                heapq.heappush(pq, [next_cost, next_i])
    return ans

print(prim(1))
```
