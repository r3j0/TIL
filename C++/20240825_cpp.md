# 윤성우의 열혈 C++ 프로그래밍
Date : 2024.08.25

## Chapter 01. C언어 기반의 C++ 1
```cpp
#include <iostream> // 헤더파일이 #include <stdio.h> 에서 #include <iostream> 이 됨.

int main(void) {
  int num = 20;
  std::cout<<"Hello World!"<<std::endl; // 출력은 기본적으로 std::cout<<출력대상1<<출력대상2<<출력대상3;
  std::cout<<"Hello "<<"World!"<<std::endl; // std::endl 은 개행
  std::cout<<num<<' '<<'A'; // 서식지정이 필요 없음.
  std::cout<<' '<<3.14<<std::endl;

  int x; // 중간에서 변수 선언이 가능.
  std::cin >> x; // 입력은 기본적으로 std::cin>>변수

  char name[100];
  std::cin >> name;

  std::cout<<x<<' '<<name<<std::endl;
  return 0;
}
```

### 함수 오버로딩
C++ 에서 함수 선언 시 동일한 이름에 매개변수의 선언이 다르게 선언이 가능하다. 이를 함수 오버로딩 (Function Overloading) 이라고 한다.
매개변수의 자료형, 수가 다를때만 오버로딩이 성립한다. 반환형만 다른 것은 오버로딩의 조건을 만족하지 않는다.

```cpp
#include <iostream>
using namespace std;

int sumNumber(int a, int b) {
  return a + b;
}

int sumNumber(int a) {
  return a + 10000;
}

int main(void) {
  cout << sumNumber(10, 20) << endl;
  cout << sumNumber(10) << endl;
  return 0;
}
```

### 디폴트 값
전달되는 인자가 왼쪽에서부터 채워지므로 디폴트 값은 오른쪽부터 채움. 선언부에만 작성해도 됨.
```cpp
#include <iostream>
using namespace std;

int sumNumber(int a, int b = 10000, int c = 20000);

int main(void) {
  cout << sumNumber(10, 20, 30) << endl;
  cout << sumNumber(10, 20) << endl;
  cout << sumNumber(10) << endl;
  return 0;
}

int sumNumber(int a, int b, int c) {
  return a + b + c;
}
```

### inline 선언 함수
매크로 함수는 인라인화 되어 성능 향상 되지만 정의 방식이 복잡함. 함수에 inline 을 선언하면 함수의 인라인화가 된다.  
매크로 함수는 자료형에 독립적이라, 인라인 함수는 오버로딩으로 선언해야 하는데, 이후에 템플릿을 학습하면 독립적으로 선언 가능하다.

```cpp
inline int SQUARE(int x) { return x*x; }
```

### 이름공간
```cpp
#include <iostream>

namespace NS1 {
  void func() {
    std::cout<<"NS1 Function"<<std::endl;
  }
}

namespace NS2 {
  void func() {
    std::cout<<"NS2 Function"<<std::endl;
  }
}

int main(void) {
  NS1::func();
  NS2::func();
}
```

```cpp
#include <iostream>

namespace NS1 {
  namespace AS1 {
    void func();
  }
  void func();
  void func2();
}
  
namespace NS2 {
  void func();
}

int main(void) {
  NS1::func();
  NS2::func();
}

void NS1::func() {
  std::cout<<"NS1 Function"<<std::endl;
  AS1::func();
  func2();
}
void NS1::func2() {
  std::cout<<"NS1 Function2"<<std::endl;
}
void NS1::AS1::func() {
  std::cout<<"NS1 AS1 Function"<<std::endl;
}
void NS2::func() {
  std::cout<<"NS2 Function"<<std::endl;
}
```
- func 함수의 선언과 정의를 분리시킬 수 있다.
- 동일한 이름공간 내에서의 호출은 그냥 함수명을 호출하면 된다.
- 이름공간은 중첩된다.
- <iostream>에 선언된 cout, cin, endl은 std 안에 선언되어 있다.

```cpp
#include <iostream>
using std::cin;

int main(void) {
  int x; cin >> x;
  std::cout << x << std::endl;
  return 0;
}
```

```cpp
#include <iostream>
using namespace std;

int main(void) {
  int x; cin >> x;
  cout << x << endl;
  return 0;
}
```
- using 을 이용해 std::cin을 cin 으로 의미하도록 하게 하거나, std를 선언 없이 접근할 수 있게 하기도 함.
- :: 는 범위지정 연산자.

```cpp
#include <iostream>

namespace AAA {
  namespace BBB {
    namespace CCC {
      int i;
    }
  }
}

namespace ABC = AAA::BBB::CCC;

int main(void) {
  ABC::i = 20;
  std::cout << ABC::i;
  return 0;
}
```
- namespace ABC = AAA::BBB; 를 통해 이름공간 별칭을 선언할 수도 있음.


```cpp
#include <iostream>
using namespace std;
int x = 10;

void func1() {
  int x = 20;
  cout << "Local : " << x << endl;
  cout << "Global : " <<  ::x << endl;
  x += 10;
  cout << "Local : " << x << endl;
  cout << "Global : " << ::x << endl;
  ::x += 10;
}

int main(void) {
  func1();
  cout << "Global : " << x << endl;
}
```
- 범위 지정 연산자를 통해 전역변수에 접근할 수도 있음.
