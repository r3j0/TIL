# 2533번: 사회망 서비스(SNS)
그래프를 그리며 풀이하다가 점화식을 찾을 수 있었다.

![tempFileForShare_20251023-111606](https://github.com/user-attachments/assets/72d433e3-4104-42bc-a680-5c18eef3a4b8)

처음에는 트리의 높이에 따라서 얼리어답터의 수를 결정하려고 했으나, (min(짝수 높이 정점의 개수, 홀수 높이 정점의 개수)) 예제 2번 입력과 같이 이웃한 경우에 얼리어답터가 있을 수 있는 경우를 고려해야 했었다.  
자신이 얼리어답터가 되는 경우 / 자신이 얼리어답터가 되지 않는 경우를 부분 트리로 나누어 얻어내서 결합할 수 있을지에 대한 방법을 고민하다가, 다음과 같은 점화식을 얻어냈다.  

- 자신이 얼리어답터가 되는 경우에는, 자식 노드가 어떤 경우에든 상관 없이 (자식이 얼리어답터든, 얼리어답터가 아니든) 부분 그래프들의 최소 경우를 더하면 최소 수를 얻어낼 수 있다.
- 자신이 얼리어답터가 되지 않는 경우에는, **주변 자식 노드가 전부 얼리어답터가 되는 경우** 만 가능하기 때문에, 해당 DP 값만 더하면 최소 수를 얻어낼 수 있다.

> ### dp[i] = i번 노드와 i번 노드의 부분 노드를 포함한 그래프에서의 최소 얼리어답터 수
> - dp[i][자신이 얼리어답터가 되는 경우] = sum(min(dp[자식 노드들]))
> - dp[i][자신이 얼리어답터가 되지 않는 경우] = sum(dp[자식 노드들][자신이 얼리어답터가 되는 경우])

루트를 1번으로 임의로 지정하고, DP 값을 역전파했을 때 min(dp[i])를 구하면 된다.

```py
# 2533 : 사회망 서비스(SNS)
import sys
from collections import deque
input = sys.stdin.readline

n = int(input().rstrip())
edges = [[] for _ in range(n+1)]
for _ in range(n-1):
    u, v = map(int, input().rstrip().split())
    edges[u].append(v)
    edges[v].append(u)

# 1. DP 값 루트부터 역전파하는 순서 만들기 (BFS)
queue = deque()
visited = [False for _ in range(n+1)]

queue.append(1)
visited[1] = True

next_edge = [-1 for _ in range(n+1)] # 전파 방향
order = deque() # 방문 순서
while queue:
    now = queue.popleft()
    for next in edges[now]:
        if not visited[next]:
            visited[next] = True
            queue.append(next)
            next_edge[next] = now
    order.appendleft(now)

# 2. DP 역전파
dp = [[1, 0] for _ in range(n+1)]
for o in order:
    if next_edge[o] == -1: continue
    dp[next_edge[o]][0] += min(dp[o])
    dp[next_edge[o]][1] += dp[o][0]

print(min(dp[1]))
```
