# 2228번: 구간 나누기

문제를 잘못 읽어서 2시간을 날렸다. `서로 다른 두 구간끼리 겹쳐있거나 인접해 있어서는 안 된다.` 라는 조건을 보지 못했다..  
DP 를 활용해, `i`번째 수까지 `j`개의 구간을 선택했을 때 구간에 속한 수들 총 합의 최댓값을 저장하면 된다.
1개의 구간을 선택할 때는 `i`번째 수까지 탐색했을 때 가장 최대 합을 가지는 구간을 저장하고,  
2개 이상의 구간을 선택할 때, "`k`번째 수까지 `s-1`개 구간을 선택했을 때 구간 총 합 + `k+2`번째 수부터 새로운 구간 1개의 구간 총 합" 을 k를 증가시키며 최댓값을 찾는 원리이다.

```py
# 2228 : 구간 나누기
import sys
input = sys.stdin.readline

n, m = map(int, input().rstrip().split())
arr = [int(input().rstrip()) for _ in range(n)]
sarr = [0]
for i in range(n): sarr.append(sarr[-1] + arr[i])

# dp[i][j] : i번째 수까지, j 개의 구간을 선택했을 때 구간에 속한 수들 총 합의 최댓값
dp = [[(-32768 * 300) for _ in range(m+1)] for _ in range(n)]

# 1. 1개의 구간을 선택했을 때
dp[0][1] = arr[0]
for i in range(1, n):
    dp[i][1] = dp[i-1][1]
    for j in range(i+1):
        dp[i][1] = max(dp[i][1], sarr[i+1] - sarr[j])


# 2. 2개 이상의 구간을 선택했을 때
for s in range(2, m+1):
    for i in range(2, n):
        dp[i][s] = dp[i-1][s]
        for k in range(i-1):
            dp[i][s] = max(dp[i][s], dp[k][s-1] + sarr[i+1] - sarr[k+2])

print(dp[n-1][m])
```
