# 16973번: 직사각형 탈출
직사각형이 움직이는 경로에 벽이 존재하는지 여부를 하나하나 체크했다. (시간이 될 것 같아 깡으로 탐색했다.)
정답을 받고 태그를 공개해보니 누적 합 태그가 있었다. 누적 합 테크닉으로 벽 존재 여부를 한 번에 앎으로써 최적화를 시킬 수 있을 것 같다.

```py
# 16973 : 직사각형 탈출
import sys
from collections import deque
input = sys.stdin.readline

n, m = map(int, input().rstrip().split())
maps = [list(map(int, input().rstrip().split())) for _ in range(n)]
h, w, sr, sc, fr, fc = map(int, input().rstrip().split())

sr -= 1; sc -= 1; fr -= 1; fc -= 1

queue = deque()
visited = [[False for _ in range(m)] for _ in range(n)]

queue.append([sr, sc])
visited[sr][sc] = True

dy = [-1, 1, 0, 0]
dx = [0, 0, -1, 1]

time = 0
done = False
while queue:
    size = len(queue)
    for _ in range(size):
        now = queue.popleft()
        if now[0] == fr and now[1] == fc: 
            done = True
            break

        for d in range(4):
            able = True
            if dy[d] != 0:
                for c in range(w):
                    ny = now[0] + (dy[d] * (1 if dy[d] == -1 else h))
                    nx = now[1] + c
                    if not (0 <= ny < n and 0 <= nx < m and maps[ny][nx] == 0):
                        able = False
            if dx[d] != 0:
                for c in range(h):
                    ny = now[0] + c
                    nx = now[1] + (dx[d] * (1 if dx[d] == -1 else w))
                    if not (0 <= ny < n and 0 <= nx < m and maps[ny][nx] == 0):
                        able = False
            nry = now[0] + dy[d]
            nrx = now[1] + dx[d]
            if able and visited[nry][nrx] == False: 
                queue.append([nry, nrx])
                visited[nry][nrx] = True

    if done: break
    time += 1

print(time if done else -1)
```

